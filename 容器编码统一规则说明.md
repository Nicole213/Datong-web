# 容器编码统一规则说明

## 更新时间
2024年

## 背景

系统中之前存在两种容器编码规则：
- **TP-XXX**：用于出库作业和盘点作业（如 TP-001、TP-002）
- **RK-XXXX-XXX**：用于入库作业（如 RK-2024-001、RK-2024-002）

为了统一管理和避免混淆，现将所有容器编码统一为 **TP-XXX** 格式。

## 统一规则

### 容器编码格式
```
TP-XXX
```

### 格式说明
- **TP**：托盘（Tray/Pallet）的缩写
- **-**：分隔符
- **XXX**：三位数字编号，从 001 开始

### 示例
- TP-001
- TP-002
- TP-003
- TP-100
- TP-999

## 适用范围

### 1. 入库作业
- 待组盘列表中的容器编码
- 扫描容器时输入的编码
- 组盘完成后的容器编码

### 2. 出库作业
- 扫描容器时输入的编码
- 容器物料明细中的容器编码
- 回库时的容器编码

### 3. 盘点作业
- 扫描容器时输入的编码
- 容器信息中的容器编码
- 盘点入库时的容器编码

### 4. 容器管理
- 容器列表中的容器编码
- 新增容器时的编码规则
- 容器查询时的编码格式

## 更新内容

### 1. 入库作业（scripts/inbound-operation.js）
```javascript
// 之前
containerCode: 'RK-2024-001'
containerCode: 'RK-2024-002'
containerCode: 'RK-2024-003'

// 现在
containerCode: 'TP-001'
containerCode: 'TP-002'
containerCode: 'TP-003'
```

### 2. 测试文件
- **测试入库作业.html**：所有 RK-2024-XXX 改为 TP-XXX
- **测试分配验证逻辑.html**：所有 RK-2024-XXX 改为 TP-XXX
- **测试出库作业.html**：保持 TP-XXX 不变
- **测试盘点作业.html**：保持 TP-XXX 不变

### 3. 文档说明
- 所有功能说明文档中的容器编码示例统一为 TP-XXX 格式

## 编码规则详解

### 编号范围
- **001-099**：小型容器（小金属框、塑料托盘等）
- **100-199**：中型容器（标准托盘）
- **200-299**：大型容器（大金属框、长物料钢托盘等）
- **300-999**：预留扩展

### 编号分配
- 按照容器入库顺序依次分配
- 容器报废后编号不重复使用
- 新容器从当前最大编号+1开始

### 特殊编号
- **TP-000**：系统保留，不使用
- **TP-999**：测试专用容器

## 数据迁移

### 历史数据处理
1. 将所有 RK-XXXX-XXX 格式的容器编码转换为 TP-XXX 格式
2. 建立编码映射表，记录新旧编码对应关系
3. 更新所有关联表中的容器编码字段
4. 保留历史记录中的原始编码用于追溯

### 映射规则
```
RK-2024-001 → TP-001
RK-2024-002 → TP-002
RK-2024-003 → TP-003
...
```

## 系统影响

### 1. 数据库
- 容器表（containers）：更新 container_code 字段
- 入库任务表（inbound_tasks）：更新 container_code 字段
- 出库任务表（outbound_tasks）：更新 container_code 字段
- 盘点任务表（inventory_tasks）：更新 container_code 字段
- 库存表（stocks）：更新 container_code 字段

### 2. 接口
- 容器查询接口：支持新编码格式
- 容器扫描接口：验证新编码格式
- 任务创建接口：使用新编码格式

### 3. 前端
- 所有容器编码输入框：提示新格式
- 容器编码验证：使用新规则
- 容器编码显示：统一格式

## 验证规则

### 格式验证
```javascript
// 正则表达式
const containerCodePattern = /^TP-\d{3}$/;

// 验证函数
function validateContainerCode(code) {
    if (!code) {
        return { valid: false, message: '容器编码不能为空' };
    }
    
    if (!containerCodePattern.test(code)) {
        return { valid: false, message: '容器编码格式错误，应为 TP-XXX（如 TP-001）' };
    }
    
    return { valid: true, message: '验证通过' };
}
```

### 存在性验证
```javascript
// 检查容器是否存在
function checkContainerExists(code) {
    // 从数据库或缓存中查询
    const container = findContainerByCode(code);
    
    if (!container) {
        return { exists: false, message: '容器编码不存在' };
    }
    
    return { exists: true, container: container };
}
```

## 测试用例

### 有效编码
- TP-001 ✓
- TP-100 ✓
- TP-999 ✓

### 无效编码
- RK-2024-001 ✗（旧格式）
- TP-1 ✗（位数不足）
- TP-0001 ✗（位数过多）
- TP001 ✗（缺少分隔符）
- tp-001 ✗（大小写错误）
- TP-ABC ✗（非数字）

## 注意事项

1. **统一性**：所有模块必须使用统一的容器编码格式
2. **兼容性**：系统需要支持旧编码的查询和转换
3. **唯一性**：每个容器编码在系统中必须唯一
4. **可追溯性**：保留编码变更历史记录
5. **扩展性**：预留足够的编号空间用于未来扩展
6. **可读性**：编码格式简洁明了，易于识别和输入
7. **标准化**：所有文档和测试数据使用统一格式

## 实施计划

### 第一阶段：代码更新
- [x] 更新入库作业脚本
- [x] 更新测试文件
- [x] 更新文档说明

### 第二阶段：数据迁移
- [ ] 备份现有数据
- [ ] 执行编码转换
- [ ] 验证数据完整性

### 第三阶段：系统测试
- [ ] 功能测试
- [ ] 集成测试
- [ ] 用户验收测试

### 第四阶段：上线部署
- [ ] 生产环境部署
- [ ] 监控运行状态
- [ ] 收集用户反馈

## 总结

通过统一容器编码规则为 **TP-XXX** 格式，系统的容器管理更加规范和统一。新的编码格式简洁明了，易于识别和输入，同时保留了足够的扩展空间。所有相关模块和文档已更新完成，确保系统的一致性和可维护性。
